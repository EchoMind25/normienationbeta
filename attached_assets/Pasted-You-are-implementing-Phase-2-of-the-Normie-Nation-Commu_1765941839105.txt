You are implementing Phase 2 of the Normie Nation Community Hub rebuild. Phase 1 (live Solana data + shop removal) is complete. This phase adds core social infrastructure: user accounts, NFT economy, and community communication. You have high autonomy - make architectural decisions that prioritize security, scalability, and user experience.
Objectives Overview
1. Authentication System

Solana wallet-based login (primary)
Email/password fallback (secondary)
JWT-based sessions
Role-based access control (User, Admin)
Password reset via email

2. User Profiles

Public profile pages
Customizable avatars
Display $NORMIE holdings (optional, wallet-linked)
Bio/social links
NFT collection showcase
Activity history (mints, gallery uploads, chat participation)

3. NFT Marketplace & Minting

Mint Normie-themed NFTs from meme generator outputs
Buy/sell/bid using $NORMIE or SOL
Royalties to community wallet
Metadata storage (IPFS or Arweave)
Integration with Metaplex standard

4. Chat System

Public chat rooms (Socket.io)
Encrypted private groups (end-to-end encryption)
Admin moderation tools
File sharing (memes, NFT previews)
Integration with user profiles

5. Admin Privileges

Designate Normie CEO wallet as admin
Capabilities: moderate chats, approve/delete gallery uploads, ban users, manage icons
Admin dashboard for oversight


Technical Specifications
PostgreSQL Schema Design
Implement these tables with proper relationships:
sql-- Users Table
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  wallet_address VARCHAR(44) UNIQUE, -- Solana wallet
  email VARCHAR(255) UNIQUE,
  password_hash VARCHAR(255), -- bcrypt hashed
  username VARCHAR(50) UNIQUE NOT NULL,
  bio TEXT,
  avatar_url TEXT,
  selected_icon_id UUID REFERENCES icons(id),
  role VARCHAR(20) DEFAULT 'user', -- 'user' or 'admin'
  holdings_visible BOOLEAN DEFAULT false,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- User Sessions
CREATE TABLE sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  token VARCHAR(500) UNIQUE NOT NULL,
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT NOW()
);

-- NFTs Table
CREATE TABLE nfts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  mint_address VARCHAR(44) UNIQUE NOT NULL, -- Solana NFT mint
  owner_id UUID REFERENCES users(id),
  creator_id UUID REFERENCES users(id),
  metadata_uri TEXT NOT NULL, -- IPFS/Arweave link
  name VARCHAR(100),
  description TEXT,
  image_url TEXT,
  price_sol DECIMAL(20, 9),
  price_normie DECIMAL(20, 9),
  royalty_percentage DECIMAL(5, 2) DEFAULT 5.0,
  status VARCHAR(20) DEFAULT 'minted', -- 'minted', 'listed', 'sold'
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- NFT Transactions
CREATE TABLE nft_transactions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  nft_id UUID REFERENCES nfts(id),
  from_user_id UUID REFERENCES users(id),
  to_user_id UUID REFERENCES users(id),
  transaction_type VARCHAR(20), -- 'mint', 'sale', 'transfer'
  price_sol DECIMAL(20, 9),
  price_normie DECIMAL(20, 9),
  tx_signature VARCHAR(88), -- Solana transaction signature
  created_at TIMESTAMP DEFAULT NOW()
);

-- Chat Rooms
CREATE TABLE chat_rooms (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(100) NOT NULL,
  type VARCHAR(20) NOT NULL, -- 'public' or 'encrypted'
  creator_id UUID REFERENCES users(id),
  encryption_key TEXT, -- For encrypted rooms (store securely)
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Chat Messages
CREATE TABLE chat_messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  room_id UUID REFERENCES chat_rooms(id) ON DELETE CASCADE,
  user_id UUID REFERENCES users(id),
  content TEXT NOT NULL, -- Encrypted if room.type = 'encrypted'
  file_url TEXT, -- Optional attachment
  is_deleted BOOLEAN DEFAULT false,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Chat Room Members
CREATE TABLE chat_room_members (
  room_id UUID REFERENCES chat_rooms(id) ON DELETE CASCADE,
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  role VARCHAR(20) DEFAULT 'member', -- 'member', 'moderator', 'admin'
  joined_at TIMESTAMP DEFAULT NOW(),
  PRIMARY KEY (room_id, user_id)
);

-- Password Reset Tokens
CREATE TABLE password_reset_tokens (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  token VARCHAR(255) UNIQUE NOT NULL,
  expires_at TIMESTAMP NOT NULL,
  used BOOLEAN DEFAULT false,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Icons Table (for customizable favicons/app icons)
CREATE TABLE icons (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(100) NOT NULL,
  file_url TEXT NOT NULL,
  uploaded_by UUID REFERENCES users(id),
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP DEFAULT NOW()
);

-- Add indexes for performance
CREATE INDEX idx_users_wallet ON users(wallet_address);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_nfts_owner ON nfts(owner_id);
CREATE INDEX idx_nfts_status ON nfts(status);
CREATE INDEX idx_chat_messages_room ON chat_messages(room_id);
CREATE INDEX idx_sessions_token ON sessions(token);

Authentication Implementation
Required Libraries:
bashnpm install @solana/web3.js @solana/wallet-adapter-react @solana/wallet-adapter-wallets
npm install jsonwebtoken bcryptjs
npm install express-validator
npm install nodemailer # For password resets
Wallet Authentication Flow:
javascript// Backend: /api/auth/wallet
// 1. Client sends wallet public key
// 2. Server generates random challenge message
// 3. Client signs message with wallet
// 4. Server verifies signature using @solana/web3.js
// 5. Issue JWT token with user_id and role

// Use nacl.sign.detached.verify() for signature validation
Email/Password Flow:
javascript// Backend: /api/auth/register
// - Validate email format
// - Hash password with bcryptjs (10 rounds)
// - Create user record
// - Send verification email

// Backend: /api/auth/login
// - Validate credentials
// - Compare bcrypt hash
// - Issue JWT (expires in 7 days)
// - Create session record
JWT Configuration:
javascript// Payload structure:
{
  userId: uuid,
  walletAddress: string | null,
  email: string | null,
  role: 'user' | 'admin',
  iat: timestamp,
  exp: timestamp
}

// Store JWT_SECRET in Replit Secrets
// Use httpOnly cookies for web (more secure than localStorage)
Admin Designation:
javascript// Hardcode Normie CEO wallet address in .env:
// ADMIN_WALLET_ADDRESS=<NormieCEO_wallet_address>

// On wallet login, check:
if (walletAddress === process.env.ADMIN_WALLET_ADDRESS) {
  user.role = 'admin';
}

Password Reset via Email
Setup SendGrid (Free Tier):

Sign up at sendgrid.com (free 100 emails/day)
Generate API key
Store in Replit Secrets: SENDGRID_API_KEY
Verify sender email

Implementation:
javascript// Backend: /api/auth/request-reset
// - Validate email exists
// - Generate crypto.randomBytes(32) token
// - Store in password_reset_tokens with 1-hour expiry
// - Send email with reset link: https://normienation.replit.app/reset?token=xxx

// Backend: /api/auth/reset-password
// - Validate token (not expired, not used)
// - Hash new password
// - Update user record
// - Mark token as used
// - Invalidate all existing sessions for that user
Email Template:
html<html>
<body style="background: #000; color: #00ff00; font-family: monospace;">
  <h2>Normie Nation Password Reset</h2>
  <p>Click below to reset your password (expires in 1 hour):</p>
  <a href="{{resetLink}}" style="color: #00ff00;">Reset Password</a>
  <p>If you didn't request this, ignore this email.</p>
</body>
</html>

User Profile System
Profile Routes:
javascript// GET /api/users/:username - Public profile view
// PUT /api/users/me - Update own profile (auth required)
// GET /api/users/me - Get own profile data
// GET /api/users/:id/nfts - User's NFT collection
// GET /api/users/:id/activity - Recent activity feed
Profile Component Features:

Avatar upload (store in Replit DB or Supabase free tier)
Display wallet holdings IF user opted in (query Solana for $NORMIE balance)
Show minted NFTs in grid
Edit bio/social links (Twitter, Telegram handles)
Icon selection dropdown (populated from icons table)

Holdings Display:
javascript// If holdings_visible = true, query Solana:
const connection = new Connection('https://solana-rpc.publicnode.com');
const tokenAccounts = await connection.getParsedTokenAccountsByOwner(
  new PublicKey(user.wallet_address),
  { mint: new PublicKey('FrSFwE2BxWADEyUWFXDMAeomzuB4r83ZvzdG9sevpump') }
);
// Display token amount

NFT Marketplace & Minting
Metaplex Integration:
bashnpm install @metaplex-foundation/js
npm install @metaplex-foundation/mpl-token-metadata
Minting Flow:
javascript// Frontend: User creates meme â†’ clicks "Mint as NFT"
// 1. Upload image to IPFS (use nft.storage free API or Pinata free tier)
// 2. Create metadata JSON (name, description, image URL, attributes)
// 3. Upload metadata to IPFS
// 4. Call Metaplex createNft() with metadata URI
// 5. User signs transaction with wallet
// 6. Store NFT record in PostgreSQL (mint_address, owner_id, metadata_uri)
Marketplace Features:
javascript// Backend routes:
// POST /api/nfts/mint - Mint new NFT
// GET /api/nfts - List all NFTs (with filters: status, price range)
// GET /api/nfts/:id - NFT details
// POST /api/nfts/:id/list - List for sale (update price, status='listed')
// POST /api/nfts/:id/buy - Purchase NFT
// POST /api/nfts/:id/bid - Place bid (store bids in separate table if implementing auctions)

// Frontend:
// - Grid view with filters (price, creator, newest)
// - Detail modal with 3D preview (if applicable)
// - "Buy with SOL" and "Buy with $NORMIE" buttons
// - Transaction confirmation with wallet signature
Royalty Implementation:
javascript// On NFT sale:
// 1. Calculate royalty: salePrice * (royalty_percentage / 100)
// 2. Transfer royalty to community wallet (hardcoded in .env)
// 3. Transfer remaining to seller
// 4. Record transaction in nft_transactions table
IPFS Setup (Free):

Use nft.storage API (free, no credit card)
API key in Replit Secrets: NFT_STORAGE_API_KEY
Upload via their SDK: npm install nft.storage


Chat System
Public Chat Implementation:
javascript// Socket.io setup:
io.on('connection', (socket) => {
  // Authenticate socket with JWT
  const token = socket.handshake.auth.token;
  const user = verifyJWT(token);
  
  // Join room
  socket.on('join_room', (roomId) => {
    socket.join(roomId);
    // Load last 50 messages from DB
  });
  
  // Send message
  socket.on('send_message', async ({ roomId, content, fileUrl }) => {
    // Store in chat_messages table
    const message = await createMessage(roomId, user.id, content, fileUrl);
    io.to(roomId).emit('new_message', message);
  });
  
  // Admin moderation
  socket.on('delete_message', async ({ messageId }) => {
    if (user.role === 'admin') {
      await markMessageDeleted(messageId);
      io.to(roomId).emit('message_deleted', messageId);
    }
  });
});
Encrypted Chat Implementation:
javascript// Use Web Crypto API (native browser support)
// End-to-end encryption strategy:

// 1. Room creation: Generate symmetric key (AES-GCM)
const key = await crypto.subtle.generateKey(
  { name: 'AES-GCM', length: 256 },
  true,
  ['encrypt', 'decrypt']
);

// 2. Share key with members securely:
// - Export key to JWK format
// - Encrypt with each member's public key (RSA-OAEP)
// - Store encrypted keys in chat_room_members table

// 3. Message encryption (client-side):
const iv = crypto.getRandomValues(new Uint8Array(12));
const encrypted = await crypto.subtle.encrypt(
  { name: 'AES-GCM', iv },
  key,
  new TextEncoder().encode(message)
);
// Send: { iv: base64(iv), content: base64(encrypted) }

// 4. Message decryption (client-side):
const decrypted = await crypto.subtle.decrypt(
  { name: 'AES-GCM', iv: base64ToArrayBuffer(msg.iv) },
  key,
  base64ToArrayBuffer(msg.content)
);

// Note: Encrypted messages appear as ciphertext in DB
// Only room members with the key can decrypt
Chat UI Requirements:

Message list (auto-scroll to bottom)
Input field with emoji picker
File upload (images, memes) - max 5MB
User avatars next to messages
Timestamp display
"Delete" button for admins
Room list sidebar (public rooms always visible, encrypted by invite)

Moderation Tools:
javascript// Admin capabilities:
// - Delete any message (mark is_deleted=true, don't remove from DB)
// - Kick user from room (remove from chat_room_members)
// - Ban user site-wide (add banned_at timestamp to users table)
// - View audit log of deleted messages

// Backend: /api/admin/chat/delete-message
// Backend: /api/admin/users/:id/ban

Admin Dashboard
Required Features:

User Management:

List all users (paginated)
View user profiles
Ban/unban users
View user activity logs


Chat Moderation:

View all rooms
Read messages (including deleted)
Delete messages
Remove users from rooms


NFT Management:

View all minted NFTs
Flag/remove inappropriate NFTs (mark as hidden)
View marketplace transactions


Icon Management:

Upload new icons (PNG/ICO)
Set icons as active/inactive
Preview how icons appear


Analytics Dashboard:

Total users, active sessions
NFTs minted/sold count
Chat activity metrics
Revenue from marketplace (if applicable)



Routes:
javascript// All require role='admin' middleware
// GET /api/admin/users - User list
// GET /api/admin/analytics - Stats summary
// POST /api/admin/icons/upload - Upload icon
// PUT /api/admin/nfts/:id/hide - Hide NFT
// GET /api/admin/chat/audit - Deleted messages log

Security Requirements
Input Validation
javascript// Use express-validator for all inputs
const { body, validationResult } = require('express-validator');

// Example: Registration validation
[
  body('email').isEmail().normalizeEmail(),
  body('password').isLength({ min: 8 }).matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/),
  body('username').isAlphanumeric().isLength({ min: 3, max: 50 }),
]
SQL Injection Prevention

Use parameterized queries ONLY (no string concatenation)
Example: db.query('SELECT * FROM users WHERE id = $1', [userId])

XSS Prevention

Sanitize all user-generated content
Use DOMPurify on frontend for rendering HTML
Content Security Policy headers

Rate Limiting
javascriptconst rateLimit = require('express-rate-limit');

// API rate limiter
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // 100 requests per window
  message: 'Too many requests, try again later'
});

// Auth endpoints: stricter limits
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5, // 5 login attempts per 15 min
});
Environment Variables Required
bash# Add to Replit Secrets:
JWT_SECRET=<random_256_bit_hex>
SENDGRID_API_KEY=<sendgrid_key>
NFT_STORAGE_API_KEY=<nft_storage_key>
ADMIN_WALLET_ADDRESS=<normie_ceo_wallet>
COMMUNITY_WALLET_ADDRESS=<royalty_destination>
DATABASE_URL=<postgres_connection_string>

Testing Requirements
After implementation, test these flows:
Authentication Tests

Register with email/password
Login with email
Connect Solana wallet and login
Request password reset email
Complete password reset flow
Verify admin wallet gets admin role
Test session expiration (7 days)

Profile Tests

Update bio and social links
Upload avatar
Toggle holdings visibility
Select different app icon
View another user's profile

NFT Tests

Mint NFT from meme generator
List NFT for sale (SOL price)
Purchase NFT with wallet
Verify royalty sent to community wallet
View NFT in user profile collection

Chat Tests

Join public room
Send text message
Upload image in chat
Create encrypted room
Invite user to encrypted room
Verify encrypted messages unreadable in DB
Admin delete message
Admin kick user from room

Admin Tests

Login as admin (Normie CEO wallet)
Access admin dashboard
Ban a test user
Delete chat message
Upload new icon
View analytics


Performance Considerations

Database Indexing: Already included in schema
Connection Pooling: Configure pg Pool with max 20 connections
Caching:

Cache NFT metadata for 5 minutes (Redis or in-memory if not available)
Cache user profiles for 1 minute


WebSocket Optimization:

Limit message history to last 50 per room load
Implement message pagination for older messages


File Uploads:

Compress images before IPFS upload (max 2MB)
Validate file types (PNG, JPG, GIF only)




UI/UX Requirements
Maintain Design System

Dark mode (#000 background, #00ff00 accent green)
4chan-inspired aesthetic
Responsive breakpoints: mobile (320px+), tablet (768px+), desktop (1024px+)

New Components Needed

Auth Modal: Login/Register tabs with wallet connect button
Profile Page: Avatar, bio, stats, NFT grid
NFT Marketplace Grid: Filterable card layout
NFT Detail Modal: Large image, metadata, buy/bid buttons
Chat Interface: Sidebar + message area + input
Admin Dashboard: Sidebar nav + content panels

Navigation Updates
javascript// Add to main nav:
- Profile (icon, dropdown: My Profile, Settings, Logout)
- NFT Marketplace
- Chat
- Gallery (upcoming Phase 3)
- Admin (only visible if role='admin')

Deliverables Checklist
After implementation, confirm:

 PostgreSQL schema created with all tables
 Wallet authentication working (test with Phantom/Solflare)
 Email/password registration and login functional
 Password reset emails sending via SendGrid
 User profiles display and editable
 NFT minting from meme generator works
 NFTs display in marketplace grid
 NFT purchases process correctly
 Public chat rooms functional with Socket.io
 Encrypted chat rooms with E2E encryption working
 Admin wallet designated correctly
 Admin dashboard accessible and functional
 All environment secrets configured
 Input validation on all forms
 Rate limiting implemented
 Mobile responsive layouts
 No console errors in browser or server


Required Agent Reporting
After implementation, provide:

Architecture Decisions:

Database connection approach (pool size, retry logic)
Authentication strategy choices
IPFS provider selected and why
Encryption implementation details


Dependencies Added:

Full list with versions
Purpose of each library


Environment Variables:

Complete list of required secrets
Instructions for obtaining API keys (SendGrid, NFT.storage)


Testing Performed:

Which flows you tested
Any failures or edge cases discovered


Known Limitations:

Free tier constraints (SendGrid 100 emails/day)
Solana RPC rate limits impact
IPFS upload speed/reliability
Concurrent user capacity estimates


Security Considerations:

Encryption key storage approach
Sensitive data handling
Potential vulnerabilities identified


Performance Metrics:

Page load times
WebSocket connection latency
Database query response times
NFT minting time (average)


Next Steps for Braxton:

Manual configuration needed
API keys to obtain
Testing scenarios to verify
Production deployment considerations




Constraints & Priorities
Must Have (Critical Path):

Wallet authentication
User profiles
NFT minting
Public chat
Admin privileges for Normie CEO wallet

Should Have (High Priority):

Password resets
Encrypted chat
NFT marketplace
Admin dashboard

Nice to Have (Lower Priority):

Activity feeds
Advanced admin analytics
NFT bidding system

Do NOT Implement Yet:

Live streaming (Phase 3)
Art gallery uploads (Phase 3)
PWA conversion (Phase 4)
Customizable icons UI (Phase 3)


Success Criteria
This phase is complete when:

A user can register and login via wallet or email
User can mint an NFT from a meme and see it in marketplace
User can join a public chat and send messages
Admin (Normie CEO) can access admin dashboard and moderate
All security measures implemented and tested
PostgreSQL properly storing all data with relationships
No breaking changes to Phase 1 features (live data, dashboard)


Begin implementation with high autonomy. Make optimal architectural decisions. Flag any blockers immediately. Provide detailed technical report upon completion.